<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Versus Search</title>
    <link rel="stylesheet" href="./1.css" />
  </head>
  <body>
    <svg class="svg-container" aria-hidden="true">
      <defs>
        <filter id="electric-flow" color-interpolation-filters="sRGB" x="-20%" y="-20%" width="140%" height="140%">
          <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="10" result="noise1" seed="1" />
          <feOffset in="noise1" dx="0" dy="0" result="offsetNoise1">
            <animate attributeName="dy" values="700;0" dur="6s" repeatCount="indefinite" calcMode="linear" />
          </feOffset>

          <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="10" result="noise2" seed="1" />
          <feOffset in="noise2" dx="0" dy="0" result="offsetNoise2">
            <animate attributeName="dy" values="0;-700" dur="6s" repeatCount="indefinite" calcMode="linear" />
          </feOffset>

          <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="10" result="noise3" seed="2" />
          <feOffset in="noise3" dx="0" dy="0" result="offsetNoise3">
            <animate attributeName="dx" values="490;0" dur="6s" repeatCount="indefinite" calcMode="linear" />
          </feOffset>

          <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="10" result="noise4" seed="2" />
          <feOffset in="noise4" dx="0" dy="0" result="offsetNoise4">
            <animate attributeName="dx" values="0;-490" dur="6s" repeatCount="indefinite" calcMode="linear" />
          </feOffset>

          <feComposite in="offsetNoise1" in2="offsetNoise2" result="part1" />
          <feComposite in="offsetNoise3" in2="offsetNoise4" result="part2" />
          <feBlend in="part1" in2="part2" mode="color-dodge" result="combinedNoise" />

          <feDisplacementMap in="SourceGraphic" in2="combinedNoise" scale="30" xChannelSelector="R" yChannelSelector="B" />
        </filter>
        <filter id="electric-flow-hue" color-interpolation-filters="sRGB" x="-20%" y="-20%" width="140%" height="140%">
          <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="7" />
          <feColorMatrix type="hueRotate" result="pt1">
            <animate attributeName="values" values="0;360;" dur=".6s" repeatCount="indefinite" calcMode="paced" />
          </feColorMatrix>
          <feComposite />
          <feTurbulence type="turbulence" baseFrequency="0.03" numOctaves="7" seed="5" />
          <feColorMatrix type="hueRotate" result="pt2">
            <animate attributeName="values" values="0;333;199;286;64;168;256;157;360;" dur="5s" repeatCount="indefinite" calcMode="paced" />
          </feColorMatrix>
          <feBlend in="pt1" in2="pt2" mode="normal" result="combinedNoise" />
          <feDisplacementMap in="SourceGraphic" scale="30" xChannelSelector="R" yChannelSelector="B" />
        </filter>
      </defs>
    </svg>

    <div class="gemini" aria-label="Fight search">
      <div class="inner-container">
        <div class="border-outer">
          <div class="inner">
            <div class="input-clip">
              <input
                id="search-input"
                aria-label="Fight search"
                autocomplete="off"
                autocapitalize="off"
                autocorrect="off"
                spellcheck="false"
                inputmode="search"
              />
            </div>
          </div>
        </div>
        <div class="glow-layer-1"></div>
        <div class="glow-layer-2"></div>
      </div>
      <div class="overlay-1"></div>
      <div class="overlay-2"></div>
      <div class="background-glow"></div>
    </div>

    <script>
      (() => {
        const input = document.getElementById('search-input');
        const searchBar = document.querySelector('.gemini');
        let collapseStarted = false;
        let collapseNotified = false;
        let collapseTimers = [];
        let expandFrameA = 0;
        let expandFrameB = 0;
        let expandFrameC = 0;
        let relayMoveRaf = 0;
        let relayMoveX = window.innerWidth * 0.5;
        let relayMoveY = window.innerHeight * 0.5;
        let disposePointerRelay = () => {};

        const postPointerRelay = (kind, x, y, down) => {
          if (!(window.parent && window.parent !== window)) return;
          window.parent.postMessage(
            {
              type: 'vvv-pointer-relay',
              source: 'search',
              event: kind,
              x,
              y,
              down,
              timestamp: performance.now(),
            },
            window.location.origin,
          );
        };

        const bindPointerRelay = () => {
          if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
            return () => {};
          }
          const root = document.documentElement;
          root.classList.add('vvv-parent-cursor');

          const flushMoveRelay = () => {
            relayMoveRaf = 0;
            postPointerRelay('move', relayMoveX, relayMoveY);
          };

          const onPointerMove = (event) => {
            relayMoveX = event.clientX;
            relayMoveY = event.clientY;
            if (!relayMoveRaf) relayMoveRaf = window.requestAnimationFrame(flushMoveRelay);
          };

          const onPointerDown = (event) => {
            relayMoveX = event.clientX;
            relayMoveY = event.clientY;
            postPointerRelay('down', relayMoveX, relayMoveY, true);
          };

          const onPointerUp = (event) => {
            relayMoveX = event.clientX;
            relayMoveY = event.clientY;
            postPointerRelay('up', relayMoveX, relayMoveY, false);
          };

          const onPointerLeave = () => {
            postPointerRelay('leave', relayMoveX, relayMoveY, false);
          };

          window.addEventListener('pointermove', onPointerMove, { passive: true });
          window.addEventListener('pointerdown', onPointerDown, { passive: true });
          window.addEventListener('pointerup', onPointerUp, { passive: true });
          window.addEventListener('pointercancel', onPointerUp, { passive: true });
          window.addEventListener('pointerleave', onPointerLeave, { passive: true });
          window.addEventListener('blur', onPointerLeave, { passive: true });

          return () => {
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerdown', onPointerDown);
            window.removeEventListener('pointerup', onPointerUp);
            window.removeEventListener('pointercancel', onPointerUp);
            window.removeEventListener('pointerleave', onPointerLeave);
            window.removeEventListener('blur', onPointerLeave);
            root.classList.remove('vvv-parent-cursor');
            if (relayMoveRaf) {
              window.cancelAnimationFrame(relayMoveRaf);
              relayMoveRaf = 0;
            }
          };
        };

        const submit = (value) => {
          const query = String(value || '').trim();
          if (!query) return;
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({ type: 'vvv-search-submit', query }, window.location.origin);
          }
        };

        const notifySearchReady = () => {
          if (!(window.parent && window.parent !== window)) return;
          window.parent.postMessage({ type: 'vvv-search-ready' }, window.location.origin);
        };

        const buildSearchHandoff = () => {
          if (!searchBar) return null;
          const barRect = searchBar.getBoundingClientRect();
          const frameRect =
            window.frameElement instanceof Element
              ? window.frameElement.getBoundingClientRect()
              : null;
          const offsetX = frameRect ? frameRect.left : 0;
          const offsetY = frameRect ? frameRect.top : 0;
          return {
            x: offsetX + barRect.left + barRect.width / 2,
            y: offsetY + barRect.top + barRect.height / 2,
            width: barRect.width,
            height: barRect.height,
          };
        };

        const startCollapse = () => {
          if (collapseStarted) return;
          collapseStarted = true;
          collapseNotified = false;
          collapseTimers.forEach((timerId) => window.clearTimeout(timerId));
          collapseTimers = [];
          if (searchBar) {
            const rect = searchBar.getBoundingClientRect();
            const collapseSize = Math.max(48, Math.round(rect.height));
            searchBar.style.setProperty('--collapse-width', `${collapseSize}px`);
          }
          document.body.classList.add('search-collapsing');
          searchBar?.classList.remove('is-collapsed', 'is-cap-fade');
          window.requestAnimationFrame(() => {
            searchBar?.classList.add('is-collapsing');
          });
          collapseTimers.push(
            window.setTimeout(() => {
              searchBar?.classList.add('is-cap-fade');
            }, 2920),
          );
          collapseTimers.push(
            window.setTimeout(() => {
              if (!collapseNotified && window.parent && window.parent !== window) {
                collapseNotified = true;
                window.parent.postMessage(
                  { type: 'vvv-search-collapsed', handoff: buildSearchHandoff() },
                  window.location.origin,
                );
              }
              searchBar?.classList.add('is-collapsed');
            }, 3220),
          );
        };

        const resetCollapse = () => {
          collapseStarted = false;
          collapseNotified = false;
          collapseTimers.forEach((timerId) => window.clearTimeout(timerId));
          collapseTimers = [];
          if (expandFrameA) {
            window.cancelAnimationFrame(expandFrameA);
            expandFrameA = 0;
          }
          if (expandFrameB) {
            window.cancelAnimationFrame(expandFrameB);
            expandFrameB = 0;
          }
          if (expandFrameC) {
            window.cancelAnimationFrame(expandFrameC);
            expandFrameC = 0;
          }
          document.body.classList.remove('search-collapsing');
          searchBar?.style.removeProperty('--collapse-width');
          searchBar?.classList.remove('is-collapsing', 'is-cap-fade', 'is-collapsed');
        };

        const primeCollapsed = () => {
          collapseStarted = true;
          collapseNotified = false;
          collapseTimers.forEach((timerId) => window.clearTimeout(timerId));
          collapseTimers = [];
          if (expandFrameA) {
            window.cancelAnimationFrame(expandFrameA);
            expandFrameA = 0;
          }
          if (expandFrameB) {
            window.cancelAnimationFrame(expandFrameB);
            expandFrameB = 0;
          }
          if (expandFrameC) {
            window.cancelAnimationFrame(expandFrameC);
            expandFrameC = 0;
          }
          if (searchBar) {
            const rect = searchBar.getBoundingClientRect();
            const collapseSize = Math.max(48, Math.round(rect.height));
            searchBar.style.setProperty('--collapse-width', `${collapseSize}px`);
            searchBar.style.transition = 'none';
          }
          document.body.classList.add('search-collapsing');
          searchBar?.classList.remove('is-collapsed', 'is-cap-fade');
          searchBar?.classList.add('is-collapsing');
          void searchBar?.offsetWidth;
          searchBar?.style.removeProperty('transition');

          if (window.parent && window.parent !== window) {
            window.parent.postMessage(
              { type: 'vvv-search-primed', handoff: buildSearchHandoff() },
              window.location.origin,
            );
          }
        };

        const expandFromPrime = () => {
          collapseStarted = false;
          collapseNotified = false;
          collapseTimers.forEach((timerId) => window.clearTimeout(timerId));
          collapseTimers = [];
          if (expandFrameA) {
            window.cancelAnimationFrame(expandFrameA);
            expandFrameA = 0;
          }
          if (expandFrameB) {
            window.cancelAnimationFrame(expandFrameB);
            expandFrameB = 0;
          }
          if (expandFrameC) {
            window.cancelAnimationFrame(expandFrameC);
            expandFrameC = 0;
          }
          document.body.classList.remove('search-collapsing');
          searchBar?.classList.remove('is-cap-fade', 'is-collapsed');
          expandFrameA = window.requestAnimationFrame(() => {
            expandFrameA = 0;
            if (searchBar) {
              void searchBar.offsetWidth;
            }
            expandFrameB = window.requestAnimationFrame(() => {
              expandFrameB = 0;
              searchBar?.classList.remove('is-collapsing');
              expandFrameC = window.requestAnimationFrame(() => {
                expandFrameC = 0;
                searchBar?.style.removeProperty('--collapse-width');
              });
            });
          });
        };

        input?.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;
          event.preventDefault();
          submit(input.value);
        });

        window.addEventListener('message', (event) => {
          if (event.origin !== window.location.origin) return;
          const payload = event.data;
          if (!payload || typeof payload !== 'object') return;
          if (payload.type === 'vvv-search-collapse') {
            startCollapse();
            return;
          }
          if (payload.type === 'vvv-search-prime-collapsed') {
            primeCollapsed();
            return;
          }
          if (payload.type === 'vvv-search-expand') {
            expandFromPrime();
            return;
          }
          if (payload.type === 'vvv-search-reset') {
            resetCollapse();
            notifySearchReady();
          }
        });

        window.addEventListener('load', () => {
          disposePointerRelay = bindPointerRelay();
          resetCollapse();
          notifySearchReady();
          if (input) {
            input.name = `vvv-search-${Math.random().toString(36).slice(2)}`;
            input.autocomplete = 'off';
            input.value = '';
          }
          input?.focus();
        });

        window.addEventListener('beforeunload', () => {
          disposePointerRelay();
        });
      })();
    </script>
  </body>
</html>
